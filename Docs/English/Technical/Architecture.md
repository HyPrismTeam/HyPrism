# Architecture

## Overview

HyPrism follows a **Console + IPC + Preact SPA** architecture pattern using [Sciter](https://sciter.com/) as the embedded web engine:

```
┌─────────────────────────────────────────────────────┐
│  .NET Console App  (Program.cs)                     │
│  ├── Bootstrapper.cs (DI container)                 │
│  ├── Services/ (business logic)                     │
│  └── IpcService.cs (IPC channel registry)           │
│         ↕ SciterIpcBridge (xcall / eval)            │
│  ┌─────────────────────────────────────────────┐    │
│  │  SciterAPIHost (EmptyFlow.SciterAPI)         │    │
│  │  └── Window (native OS window)              │    │
│  │       └── SciterIpcWindowHandler            │    │
│  │            ↕ xcall / __hyprismReceive       │    │
│  │       ┌─────────────────────────────┐       │    │
│  │       │  Preact SPA                 │       │    │
│  │       │  ├── App.tsx (routing)      │       │    │
│  │       │  ├── pages/ (views)         │       │    │
│  │       │  ├── components/ (shared)   │       │    │
│  │       │  └── lib/ipc.ts (generated) │       │    │
│  │       └─────────────────────────────┘       │    │
│  └─────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────┘
```

## Startup Flow

1. `Program.Main()` initializes Serilog logger
2. `Bootstrapper.Initialize()` builds the DI container
3. `SciterBootstrap()` creates a `SciterAPIHost` (loads the Sciter native library)
4. `host.CreateMainWindow()` opens the native OS window
5. `bridge.Attach(host, window)` registers the IPC event handler on the window
6. `IpcService.RegisterAll()` registers all IPC channel handlers
7. `host.LoadFile("file://...wwwroot/index.html")` loads the Preact SPA
8. `host.Process()` blocks — runs the native message loop until the window closes

## Communication Model

All frontend ↔ backend communication uses **named IPC channels**:

```
Channel naming: hyprism:{domain}:{action}
Examples:       hyprism:game:launch
                hyprism:settings:get
                hyprism:i18n:set
```

### Channel Types

| Type | Direction | Pattern |
|------|-----------|---------|
| **send** | Preact → .NET (fire-and-forget) | `send(channel, data)` |
| **invoke** | Preact → .NET → Preact (request/reply) | `invoke(channel, data)` → waits for `:reply` |
| **event** | .NET → Preact (push) | `on(channel, callback)` |

### Transport: JS → C\#

The frontend calls into the C# backend using the Sciter `xcall` mechanism:

```typescript
// generated by ipc.ts — consumer never calls this directly
Window.this.xcall('hyprismCall', channel, JSON.stringify(data));
```

`SciterIpcWindowHandler.ScriptMethodCall()` receives the call and dispatches it to the registered handler.

### Transport: C\# → JS

The backend pushes events to the frontend by evaluating a global JavaScript function:

```csharp
host.ExecuteWindowEval(window,
    $"typeof __hyprismReceive === 'function' && __hyprismReceive({channelJson},{json})",
    out _);
```

`__hyprismReceive` is defined by the generated `ipc.ts` bootstrap and dispatches to registered `on()` listeners.

## Dependency Injection

All services are registered as singletons in `Bootstrapper.cs`:

```csharp
var services = new ServiceCollection();
services.AddSingleton<SciterIpcBridge>();
services.AddSingleton<ISciterIpcBridge>(sp => sp.GetRequiredService<SciterIpcBridge>());
services.AddSingleton<IpcService>();
// ... etc
return services.BuildServiceProvider();
```

`IpcService` receives all other services through constructor injection and acts as the central bridge between Preact and .NET.

